#define F_CPU 1000000L
#include <stdbool.h>
#include <avr/io.h>
#include <avr/interrupt.h>
#include <util/delay.h>
#include <stdint.h>
#include "disp.h"
//--------------------------------------------
extern unsigned char R[4];               // Массив под индикатор, объявляем с другого файла 
static volatile short cnt=0;             // Подсчёт энкодера     
static uint8_t prog_step = 2;            // Шаг подсчета  

extern bool retention; // Защитимся от удержании кнопки

// Заводим таймер 
static void timer_ini(void)
{
	TCCR1B |= (1<<WGM12); // Устанавливаем режим СТС (сброс по совпадению)
	TIMSK |= (1<<OCIE1A); // Устанавливаем бит разрешения прерывания 1ого счетчика по совпадению с OCR1A(H и L)
	OCR1AH = 0b00000000;  // Записываем в регистр число для сравнения
	OCR1AL = 0b01100100;  
	TCCR1B |= (1<<CS10);  // Установим делитель.
}

// Действия при прерывание по таймеру
ISR (TIMER1_COMPA_vect)
{
	static unsigned char new_state=0; // Переменные энкодера
	static unsigned char old_state=0; // Переменные энкодера

	new_state = (PINC & 0b00110000) >> 4;
	
	// Если вдруг обнаружим низкое состояние (кнопка нажата), то обнулим счётчик
	if(!(PIND & 0b00010000)) cnt = 0; 
	
	switch(old_state | new_state) // Обработка импульсов с энкодера 
	{
		case 0x01: case 0x0e:
		cnt++;
		break;
		case 0x04: case 0x0b: 
		cnt--;
		break;
	}
	old_state = new_state << 2;
}

// Начинаем начинать 
int main(void)
{
	short cnt_local = 0;    // Для сохранения подсчета внутри критической секции
	extern bool update;     // Флаг перерисовки дисплея, с другого файла 
	extern bool klik_Down; // Состаяние кнопки Down, с другого файла
	extern bool klik_Up;   // Состаяние кнопки Up, с другого файла
	bool update_cnt = false;// Флаг пересчета
	
	DDRC  &= ~0b00110000;   // Вход энкодера
	PORTC |=  0b00110000;   // Подтяжка
	DDRD  &= ~0b00011100;   // Кнопка сброса, down и up
	PORTD |=  0b00011100;   // Подтяжка
	//--------------------------------------------
	disp_init(); // Подключаем дисплей 
	timer_ini(); // Таймер для опроса энкодера 
	//--------------------------------------------
	sei(); // Разрешаем прерывания. Это важно!
	
	ledprintRun(); // Приветствие Бегущей строкой 

// Выводим режимы подсчета при нажатой кнопке 
	void Prog_print(void)
	{
		retention = false; // Выполним один раз на один клик кнопки, без удержаний 
		klik_Up = false; // Сбрасываем флаг, иначи не прекрашает переключать
		klik_Down = false;
		static unsigned char Rp[4] = {'P','r',' ','0'};    // Обьявим локальный массив для разрядов вывода программы
		Rp[3] = '0' + prog_step;
		
		cli();            // Открываем критическую секцию
		for (int x = 0; x < sizeof(R) / sizeof(R[0]);  x++)
		{
			R[x] = Rp[x]; // Обновляем Локальную копию массива регистров
		}
		sei();            // Закрываем критическую секцию
		
		_delay_ms(20);    
		update_cnt = true;
	}
		
	//--------------------------------------------	
	while(1)
	{
		buttons_ringing (); // Обрабатываем звон контакта кнопки
		
		//--------------------------------------------
		cli();                // Открываем критическую секцию 
		if (cnt_local != cnt || update_cnt) // Если счетчик изменился?
		{
			update_cnt = false; // Сбросим флаг пересчета 
			
			// Обновляем Локальную копию счетчика + шаг программы 
			if (prog_step > 2) cnt_local = cnt / (prog_step / 2); 
			
			// по факту один подсчет экодера уже равен 2 и по этому prog_step / 2, чтобы получилось 1,2,4
			else cnt_local = cnt;
			update = true;      // Устанавливаем флаг перерисовки дисплея
		}
		sei();                // Закрываем критическую секцию
		
		//--------------------------------------------
		if (update)           // Флаг установлен?
		{
			update = false;   // Сбрасывем флаг
			/*
			из отрицательного числа делаем положительное 
			что бы не зависть от направления вращения энкодера после включения
			*/
			disp_out(cnt_local >= 0 ? cnt_local : -cnt_local); // Шедевр простоты !!!
		}
				
		//--------------------------------------------
		// Добавил вывод на экран программы и систему ее переключения
		// Получилось очень растянуто, уверен что можно перепесать более грамотно 
		
		if(klik_Up && prog_step < 8) // Инкрементируем шаг программы при нажатой кнопки 
		{
			prog_step *= 2;
			Prog_print();
		}
		if(klik_Down && prog_step > 2) // Декрементируем шаг 
		{
			prog_step /= 2;
			Prog_print();
		}
		if((klik_Up && prog_step == 8) || (klik_Down && prog_step == 2)) // Подскажем что мы в крайних положениях программы 
		{
			Prog_print();
		}
	}
}